Описание итогового проекта курса SkillBox "Разработчик C++  с нуля" .
Название проекта - "SearchServer"

Что надо было сделать:

По ихсодному заданию курса нужно было реализовать классы SearchServer, InvertedIndex, ConvertJSON - осуществляющих, во взаимодействии, многопоточную индексацию файлов указанных в файле конфигурации json(с составлением словаря) и выполняющих поисковые запросы из файла json с сохранением, отсортированных по уменьшению относительных релевантности, результатов в json файл.
Выборка ответов должна быть ограничена числом указанным в настройках. Сервер должен перед запуском проверять свои настройки и выводить сообщения об ошибках. Функции индексации, выборки ответов должны быть протестированы с помощью googletest. 
Полное описание итогового проекта доступно по ссылке: https://disk.yandex.ru/i/pnv4aDhYEyYIgg

Что было сделано:
Реализованы классы SearchServer, AsioServer, session, Settings, ThreadPool, InvertedIndex, DocPath, RelativIndex, Word выполняющие следующих функционал:

SearchServer:
-проверяет корректоность настроек сервера, выбрасывает соответствующие исключения в случае их неправильности;
- отображает текущие настройки сервера;
- запускает в отдельном потоке переодическое обновление словаря (переиндексацию файлов);
- передает в InvertedIndex вектор путей файлов подлежащих индексации, получаемых из настроек (перечислены явно или просто все из папки).
- запускает в отдельном потоке асио-сервер;
- выполняет поисковые запросы, формирует ответы;
- имеет возможность работать в режимах точного и не точного поиска(см. подробнее в SerchServer.cpp);
- записывает информацию о своей работе в лог-файл.

InvertedIndex:
- в многопоточном режиме производит индексацию файлов с составлением словаря;
- записывает информацию о своей работе в лог-файл;
- корректирует словарь при изменении, удалении, добавлении новых файлов.

DocPath:
- предоставляет классу InvertedIndex сведения о новых (и/или измененных) файлах подлжещих индексации и добавлению в словарь;
- предоставляет классу InvertedIndex сведения о файлах подлежащих удалению из словаря.

RelativIndex:
- участвует в подсчете релевантности файлов соответствующих поисковому запросу.

Word:
- участвует в получении выборки файлов содержащих все слова из поискового запроса (если сервер работает в режиме точного поиска).

Settings:
- хранит и отображает настройки сервера.

AsioServer:
- устанавливает и разрывает соединения с клиентами сервера;
- запускает соответствующие кадому клиенту сессии в асинхронном режиме.

session:
- получает от клиента команду (хедер) и информацию запроса, читая из сокета;
- отправляет ответ клиенту, записывая команду (хедер) и информацию содержащую ответ в сокет;
- проверяет корректность хедера запроса поступающего от клиента, разрывает соединение в случае некорректности, c отправлением клиенту уведомления об ошибке.
- передает SearchServer поисковые запросы поступившие от клиентов, получает от SearchServer ответы;
- передает клиенту текст запрашиваемого файла.

ThreadPool:
- предстваляет InverrtedIndex пул потоков для произведения индексации файлов.

ConvertJSON:
- получает/записывает настройки из/в  класс(а) Settings;
- получает запросы из json файла;
- записывает ответы в json файл;
- выбрасывает исключения в случае некорректности обрабатываемых json файлов.

Какие инструменты (конструкции языка с++ были использованы):

lambda:
	- для использования с совместно с algorithm;
	- передачи задач потокам;
	- для не создавания маленьких функций, ради функционального разделения кода;
	- и наверное ради чего-то еще...

"for auto"
	- для доступа к элементам коллекций.

auto
	- чтобы не писать длинные типы.

typedef
	- чтобы не писать длинные типы и было понятно для чего нужен сложносоставной контейнер.

<algorithm>: 
	- transform для приведения текстов файлов к единому формату (только буквы нижнего регистра и цифры);
	- copy_if для выборки новых (измененных) файлов ('сравнения' сетов);
	- set_intersection для получения множества файлов содержащих все слова поискового запроса;
        - all_of для проверки не получилось ли так, что все файлы отсутствуют;
	- set_difference для удаления из сета путей файлов подлежащих индексации путей удаленных файлов;

<fstream>
	- для ведения лог-файла;
	- для чтения/записи json файлов;
	- для получения текстов фалов для их последующей индексации или отправки по запросу клиенту.

<map>
	- для создания карт не подлежащих последующему редактированию.

<unordered_map>
	- для создания карт подлежащих последующему редактированию (чтобы операции удаления, добавления были за О(1)).

set(unordered_set)
	- аналогично map и unordered_map но только для множеств.

<tuple>
	- для возврата из функции нескольких элементов и удобного распределения возращаемых значение через std::tie.

<filesystem>
	- для получения всех путей файлов из папки включая подпапки через рекурсивный итератор;
	- для проверки существания файла;
	- для проверки, что файл это файл (а не папка  к примеру);
	- для получения времени последнего изменения файла и последущего принятия решения о его переиндексации.

<chrono>
	- для засекания времени выполнения кода и последующего анализа его эффективности.

<atomic>
	- для создания атомарных булевых переменных (хранящих состояние работы/не работы привыполнении индексации файлов или выполнении запросов в разных потоках).

<boost/asio.hpp>
	- для создания асинхронного-сервера выполняющего запросы по сети.

<iostream>
	- для ввода вывода информации в консоль.

"типы со строго заданным размером (например uint_fast64_t)"
	- чтобы сервер мог взаимодествовать с клиентами с разными ОС.

enum Class
	- для создания именнованых констант с понятным назначением;
	- возможностью наследования от типов со строго заданным размером (enum class COMMAND : uint_fast64_t)
наследование от std::enable_shared_from_this<session>;
	- ипользуется при определении класса session, какая-то очень крутая и серьезная весчь, кажется 	нужна чтобы создавать экземпляры класса, через shared_from_this,п ока до конца не разобрался 	как работает.

<vector>
	- для хранения данных и доступа к ним по индексу.

<list>
	- для хранения и быстрой сортировки больших структур данных.

googletest
	- для тестирования кода.

json
	- для сериализации/десиреализации структур данных (настройки сервера, запросы, ответы).

template
    - для создания структуры засекающее время выполнения любой функции (совместно с "...Args");
    - для создания очереди задач состоящей из любых функций (совместно с "...Args").

Паттерн Singelton
	- для классов InvertedIndex, SearchServer, Settings - т.к. не подразумевается создание 	нескольких экземпляров этих классов, а их работа предусматривает сильное взаимодействие между 	собой, + сингелтон предоставляет глобальный доступ к единственному экземпляру класса через 	статический метод, поэтому получилось избавиться от передачи между классами указателей(ссылок) 	на друг друга и упростить сигнатуры многих функций.

<thread>
	- для создания потоков (std::thread), упраления ими, распаралелливания кода:).

thread_pool
	- для наиболее эффективного использования многоядерных(процессорных) систем. Время на 	индексацию, по сравнению с созданием отдельного потока для индексации каждого файла, 	уменьшилось 2 раза, плюс нагрузка на цп была меньше, и более равномерная, затраты на 	оперативную память в разы меньше, т.к. не создаются тысячи экземпляров std::thread (на каждый файл, если файлов тысячи).

<mutex>
	- для разделения доступа к совместно используемым ресурсам между потоками.

lock_guard
	- см. <mutex> только еще +RAII не надо думать о разблокировке, создал и забыл.

unick_lock
	- см. lock_guard + можно самому заблочить/разблочить мьютекс, незаменимая весчь при работе с 	condition_variable.

condition_variable
	- для уведомления потоков о наступлении некоторого события (используется в thread_pool)

<queue>
	- для создания структур хранения данных по принципу очередей (первый зашел - первый вышел) (используется в thread_pool)

<functional>, <future>
	- используется в thread_pool, как работает еще разбираюсь...









